// apply_wtp.cjs
// Applies multi-cohort WTP expansion logic to months generated by calculations.js
const TIERS = ["enterprise", "large", "medium", "small", "tiny"];
const PRODUCTS = [
  "saber",
  "ter",
  "executarNoLoyalty",
  "executarLoyalty",
  "potencializar",
];

const TIER_MULTIPLIERS = {
  enterprise: 1.0,
  large: 2.0,
  medium: 1.0,
  small: 0.5,
  tiny: 0.5,
};

function applyWTP(months, inputs) {
  // Initialize wtpData and cohorts
  for (const m of months) {
    m.wtpData = m.wtpData || {};
    for (const t of TIERS) {
      m.wtpData[t] = m.wtpData[t] || {
        goLiveClients: 0,
        revenueAtGoLive: 0,
        expansionGoal: 0,
        numExpansions: 0,
        revenueExpansion: 0,
        expansionByProduct: {
          saber: 0,
          ter: 0,
          executarNoLoyalty: 0,
          executarLoyalty: 0,
          potencializar: 0,
        },
        shareOfWalletActived: 0,
      };
    }
    m.totalWTPExpansionRevenue = 0;
  }

  const wtpCohorts = {
    enterprise: [],
    large: [],
    medium: [],
    small: [],
    tiny: [],
  };

  for (let monthIndex = 0; monthIndex < months.length; monthIndex++) {
    const month = months[monthIndex];
    const monthNum = month.month; // 1-based
    // Create cohorts from this month's revenueAtGoLive (activations revenue)
    for (const tier of TIERS) {
      const revenueAtGoLive = Object.values(
        month.revenueByTierProduct[tier] || {}
      ).reduce((s, v) => s + (v || 0), 0);
      if (revenueAtGoLive > 0) {
        wtpCohorts[tier].push({
          monthOfBirth: monthNum,
          revenueAtGoLive,
          shareOfWalletActived: 0,
        });
        month.wtpData[tier].goLiveClients += month.activations[tier] || 0;
        month.wtpData[tier].revenueAtGoLive += revenueAtGoLive;
      }
    }

    // For each existing cohort, calculate target for this month (aiming to satisfy next month's goal)
    for (const tier of TIERS) {
      const metrics = inputs.tierMetrics[tier];
      const expDist =
        tier === "enterprise" || tier === "large"
          ? inputs.expansionDistribution.largeEnterprise
          : tier === "medium"
          ? inputs.expansionDistribution.medium
          : inputs.expansionDistribution.smallTiny;
      const tierDesiredArray =
        (inputs.wtpConfig &&
          inputs.wtpConfig[tier] &&
          inputs.wtpConfig[tier].shareOfWalletDesired) ||
        Array(12).fill(0);
      const tierMultiplier = TIER_MULTIPLIERS[tier] || 1;

      for (const cohort of wtpCohorts[tier]) {
        // enforce 1-month lag: skip cohorts born this month
        if (cohort.monthOfBirth === monthNum) continue;
        const age = monthNum - cohort.monthOfBirth + 1; // 1-based
        const nextDesiredPercent = tierDesiredArray[age] || 0;
        const targetGoal =
          age + 1 === 1
            ? cohort.revenueAtGoLive * tierMultiplier
            : cohort.revenueAtGoLive * nextDesiredPercent * tierMultiplier;
        if (!targetGoal || targetGoal <= 0) continue;

        // expected revenue per expansion unit based on product mix
        let expectedRevenuePerExp = 0;
        const unitRevenueByProduct = {};
        for (const product of PRODUCTS) {
          const ticket =
            (metrics.productTickets &&
              metrics.productTickets[product] &&
              metrics.productTickets[product][monthIndex]) ||
            0;
          let unitRev = 0;
          if (product === "executarNoLoyalty")
            unitRev = ticket * (inputs.conversionRates.noLoyaltyDuration || 1);
          else if (product === "executarLoyalty")
            unitRev =
              ticket *
              (typeof inputs.conversionRates.loyaltyDuration === "number"
                ? inputs.conversionRates.loyaltyDuration
                : (inputs.conversionRates.loyaltyDuration &&
                    inputs.conversionRates.loyaltyDuration[tier]) ||
                  1);
          else unitRev = ticket;
          unitRevenueByProduct[product] = unitRev;
          const weight = expDist[product] || 0;
          expectedRevenuePerExp += weight * unitRev;
        }
        if (!expectedRevenuePerExp || expectedRevenuePerExp <= 0) continue;

        const remainingTarget = Math.max(
          0,
          targetGoal - cohort.shareOfWalletActived
        );
        const numExpansions = Math.floor(
          remainingTarget / expectedRevenuePerExp
        );
        if (numExpansions <= 0) continue;

        // integer allocation
        const clientsByProduct = {
          saber: 0,
          ter: 0,
          executarNoLoyalty: 0,
          executarLoyalty: 0,
          potencializar: 0,
        };
        let totalAssigned = 0;
        for (const product of PRODUCTS) {
          const c = Math.floor(numExpansions * (expDist[product] || 0));
          clientsByProduct[product] = c;
          totalAssigned += c;
        }
        let remainder = numExpansions - totalAssigned;
        if (remainder > 0) {
          const order = PRODUCTS.slice().sort(
            (a, b) =>
              (unitRevenueByProduct[a] || 0) - (unitRevenueByProduct[b] || 0)
          );
          let oi = 0;
          while (remainder > 0) {
            const p = order[oi % order.length];
            if ((expDist[p] || 0) > 0) {
              clientsByProduct[p] += 1;
              remainder -= 1;
            }
            oi += 1;
          }
        }

        // compute revenue per product and accumulate
        let revenueSum = 0;
        for (const product of PRODUCTS) {
          const clients = clientsByProduct[product] || 0;
          const ticket =
            (metrics.productTickets &&
              metrics.productTickets[product] &&
              metrics.productTickets[product][monthIndex]) ||
            0;
          let revenueForProduct = 0;
          // Treat tickets as TCV (total contract value) for expansion revenue.
          // Do NOT multiply by duration here â€” the plan spreadsheet uses ticket as TCV.
          revenueForProduct = clients * ticket;

          month.activeBaseExpansions[tier][product] =
            (month.activeBaseExpansions[tier][product] || 0) + clients;
          month.activeBaseExpansionRevenue[tier][product] =
            (month.activeBaseExpansionRevenue[tier][product] || 0) +
            revenueForProduct;
          month.expansions[tier][product] =
            (month.expansions[tier][product] || 0) + clients;
          month.expansionRevenue[tier][product] =
            (month.expansionRevenue[tier][product] || 0) + revenueForProduct;
          month.totalExpansionRevenue =
            (month.totalExpansionRevenue || 0) + revenueForProduct;
          month.wtpData[tier].expansionByProduct[product] =
            (month.wtpData[tier].expansionByProduct[product] || 0) +
            revenueForProduct;

          revenueSum += revenueForProduct;
        }

        month.wtpData[tier].expansionGoal =
          (month.wtpData[tier].expansionGoal || 0) + targetGoal;
        month.wtpData[tier].numExpansions =
          (month.wtpData[tier].numExpansions || 0) + numExpansions;
        month.wtpData[tier].revenueExpansion =
          (month.wtpData[tier].revenueExpansion || 0) + revenueSum;
        month.totalWTPExpansionRevenue =
          (month.totalWTPExpansionRevenue || 0) + revenueSum;

        cohort.shareOfWalletActived += revenueSum;
      }
    }
  }

  return months;
}

module.exports = { applyWTP };
